# 第七章：獲取資料

既然您已經建立並填充了資料庫，讓我們來討論獲取應用程式資料的不同方法，並建構您的儀表板概覽頁面。

## 在本章中...

以下是我們將涵蓋的主題：

- 了解幾種獲取資料的方法：API、ORM、SQL 等。
- 伺服器元件 (Server Components) 如何幫助您更安全地存取後端資源。
- 什麼是網路瀑布 (network waterfalls)。
- 如何使用 JavaScript 模式實現平行資料獲取。

## 選擇如何獲取資料

### API 層

API 是您的應用程式碼和資料庫之間的中介層。在以下幾種情況下，您可能會使用 API：

- 如果您正在使用提供 API 的第三方服務。
- 如果您從客戶端獲取資料，您會希望有一個在伺服器上運行的 API 層，以避免將您的資料庫密鑰暴露給客戶端。

在 Next.js 中，您可以使用路由處理器 (Route Handlers) 來建立 API 端點。

### 資料庫查詢

當您建立一個全端應用程式時，您還需要編寫與資料庫互動的邏輯。對於像 Postgres 這樣的關聯式資料庫，您可以使用 SQL 或 ORM 來實現。

在以下幾種情況下，您需要編寫資料庫查詢：

- 在建立您的 API 端點時，您需要編寫與資料庫互動的邏輯。
- 如果您正在使用 React 伺服器元件（在伺服器上獲取資料），您可以跳過 API 層，直接查詢您的資料庫，而不會有將資料庫密鑰暴露給客戶端的風險。

讓我們更深入地了解 React 伺服器元件。

## 使用伺服器元件獲取資料

預設情況下，Next.js 應用程式使用 React 伺服器元件。使用伺服器元件獲取資料是一種相對較新的方法，它有幾個好處：

- 伺服器元件支援 JavaScript 的 Promises，為像資料獲取這樣的非同步任務提供了原生的解決方案。您可以使用 `async/await` 語法，而無需 `useEffect`、`useState` 或其他資料獲取函式庫。
- 伺服器元件在伺服器上運行，因此您可以將耗費資源的資料獲取和邏輯保留在伺服器上，只將結果發送給客戶端。
- 由於伺服器元件在伺服器上運行，您可以直接查詢資料庫，無需額外的 API 層。這可以讓您省去編寫和維護額外程式碼的麻煩。

## 使用 SQL

對於您的儀表板應用程式，您將使用 `postgres.js` 函式庫和 SQL 來編寫資料庫查詢。我們使用 SQL 有幾個原因：

- SQL 是查詢關聯式資料庫的行業標準（例如，ORM 在底層也是生成 SQL）。
- 對 SQL 有基本了解可以幫助您理解關聯式資料庫的基礎知識，使您能夠將知識應用於其他工具。
- SQL 功能多樣，允許您獲取和操作特定的資料。
- `postgres.js` 函式庫提供了防止 SQL 注入的保護。

如果您以前沒有用過 SQL，別擔心——我們已經為您提供了所有查詢。

前往 `/app/lib/data.ts`。在這裡您會看到我們正在使用 `postgres`。`sql` 函數允許您查詢資料庫：

`/app/lib/data.ts`

```ts
import postgres from "postgres";

const sql = postgres(process.env.POSTGRES_URL!, { ssl: "require" });

// ...
```

您可以在伺服器上的任何地方呼叫 `sql`，像在伺服器元件。但為了讓您更容易地導覽元件，我們將所有資料查詢都保留在 `data.ts` 檔案中，您可以將它們匯入到元件中。

> **注意**：如果您在第六章中使用了自己的資料庫提供商，您需要更新資料庫查詢以適應您的提供商。您可以在 `/app/lib/data.ts` 中找到這些查詢。

## 為儀表板概覽頁面獲取資料

現在您了解了獲取資料的不同方法，讓我們來為儀表板概覽頁面獲取資料。導航到 `/app/dashboard/page.tsx`，貼上以下程式碼，並花些時間探索它：

`/app/dashboard/page.tsx`

```tsx
import { Card } from "@/app/ui/dashboard/cards";
import RevenueChart from "@/app/ui/dashboard/revenue-chart";
import LatestInvoices from "@/app/ui/dashboard/latest-invoices";
import { lusitana } from "@/app/ui/fonts";

export default async function Page() {
  return (
    <main>
      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Dashboard
      </h1>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        {/* <Card title="Collected" value={totalPaidInvoices} type="collected" /> */}
        {/* <Card title="Pending" value={totalPendingInvoices} type="pending" /> */}
        {/* <Card title="Total Invoices" value={numberOfInvoices} type="invoices" /> */}
        {/* <Card title="Total Customers" value={numberOfCustomers} type="customers" /> */}
      </div>
      <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
        {/* <RevenueChart revenue={revenue}  /> */}
        {/* <LatestInvoices latestInvoices={latestInvoices} /> */}
      </div>
    </main>
  );
}
```

上面的程式碼是故意註解掉的。我們現在將開始逐一解釋每個部分。

- 該頁面是一個 `async` 伺服器元件。這允許您使用 `await` 來獲取資料。
- 還有 3 個接收資料的元件：`<Card>`、`<RevenueChart>` 和 `<LatestInvoices>`。它們目前被註解掉了，尚未實現。

### 為 `<RevenueChart/>` 獲取資料

要為 `<RevenueChart/>` 元件獲取資料，請從 `data.ts` 匯入 `fetchRevenue` 函數，並在您的元件內部呼叫它：

`/app/dashboard/page.tsx`

```tsx
import { Card } from "@/app/ui/dashboard/cards";
import RevenueChart from "@/app/ui/dashboard/revenue-chart";
import LatestInvoices from "@/app/ui/dashboard/latest-invoices";
import { lusitana } from "@/app/ui/fonts";
import { fetchRevenue } from "@/app/lib/data";

export default async function Page() {
  const revenue = await fetchRevenue();
  // ...
}
```

接下來，讓我們：

1.  取消 `<RevenueChart/>` 元件的註解。
2.  導航到元件檔案 (`/app/ui/dashboard/revenue-chart.tsx`) 並取消其中的程式碼註解。

檢查 `localhost:3000/dashboard`，您應該會看到一個使用 `revenue` 資料的圖表。

讓我們繼續匯入更多資料並在儀表板上顯示。

### 為 `<LatestInvoices/>` 獲取資料

對於 `<LatestInvoices />` 元件，我們需要獲取最新的 5 筆發票，並按日期排序。

您可以獲取所有發票，然後使用 JavaScript 進行排序。由於我們的資料量很小，這不是問題，但隨著您的應用程式增長，這可能會顯著增加每次請求傳輸的資料量以及排序所需的 JavaScript 運算量。

與其在記憶體中對最新發票進行排序，您可以使用 SQL 查詢只獲取最後 5 筆發票。例如，這是您 `data.ts` 檔案中的 SQL 查詢：

`/app/lib/data.ts`

```ts
// 獲取最後 5 筆發票，按日期排序
const data = await sql<LatestInvoiceRaw[]>`
  SELECT invoices.amount, customers.name, customers.image_url, customers.email
  FROM invoices
  JOIN customers ON invoices.customer_id = customers.id
  ORDER BY invoices.date DESC
  LIMIT 5`;
```

在您的頁面中，匯入 `fetchLatestInvoices` 函數：

`/app/dashboard/page.tsx`

```tsx
import { Card } from "@/app/ui/dashboard/cards";
import RevenueChart from "@/app/ui/dashboard/revenue-chart";
import LatestInvoices from "@/app/ui/dashboard/latest-invoices";
import { lusitana } from "@/app/ui/fonts";
import { fetchRevenue, fetchLatestInvoices } from "@/app/lib/data";

export default async function Page() {
  const revenue = await fetchRevenue();
  const latestInvoices = await fetchLatestInvoices();
  // ...
}
```

然後，取消 `<LatestInvoices />` 元件的註解。您還需要取消位於 `/app/ui/dashboard/latest-invoices.tsx` 的 `<LatestInvoices />` 元件本身中的相關程式碼的註解。

如果您訪問 localhost，您應該會看到只返回了資料庫中的最後 5 筆發票。希望您開始看到直接查詢資料庫的好處了！

### 練習：為 `<Card>` 元件獲取資料

現在輪到您為 `<Card>` 元件獲取資料了。卡片將顯示以下資料：

- 已收款的發票總金額。
- 待處理的發票總金額。
- 發票總數。
- 客戶總數。

同樣，您可能會想獲取所有發票和客戶，然後使用 JavaScript 來處理資料。例如，您可以使用 `Array.length` 來獲取發票和客戶的總數：

```javascript
const totalInvoices = allInvoices.length;
const totalCustomers = allCustomers.length;
```

但是使用 SQL，您可以只獲取您需要的資料。這比使用 `Array.length` 要長一點，但這意味著在請求期間需要傳輸的資料更少。這是 SQL 的替代方案：

`/app/lib/data.ts`

```ts
const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
```

您需要匯入的函數叫做 `fetchCardData`。您需要解構該函數返回的值。

**提示：**

- 檢查 `<Card>` 元件以了解它們需要什麼資料。
- 檢查 `data.ts` 檔案以了解該函數返回什麼。

`/app/dashboard/page.tsx`

```tsx
import { Card } from "@/app/ui/dashboard/cards";
import RevenueChart from "@/app/ui/dashboard/revenue-chart";
import LatestInvoices from "@/app/ui/dashboard/latest-invoices";
import { lusitana } from "@/app/ui/fonts";
import {
  fetchRevenue,
  fetchLatestInvoices,
  fetchCardData,
} from "@/app/lib/data";

export default async function Page() {
  const revenue = await fetchRevenue();
  const latestInvoices = await fetchLatestInvoices();
  const {
    numberOfInvoices,
    numberOfCustomers,
    totalPaidInvoices,
    totalPendingInvoices,
  } = await fetchCardData();

  return (
    <main>
      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Dashboard
      </h1>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <Card title="Collected" value={totalPaidInvoices} type="collected" />
        <Card title="Pending" value={totalPendingInvoices} type="pending" />
        <Card title="Total Invoices" value={numberOfInvoices} type="invoices" />
        <Card
          title="Total Customers"
          value={numberOfCustomers}
          type="customers"
        />
      </div>
      <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
        <RevenueChart revenue={revenue} />
        <LatestInvoices latestInvoices={latestInvoices} />
      </div>
    </main>
  );
}
```

太棒了！您現在已經為儀表板概覽頁面獲取了所有資料。您的頁面應該看起來像這樣。

然而... 有兩件事您需要注意：

1.  資料請求無意中相互阻塞，形成了一個請求**瀑布 (waterfall)**。
2.  預設情況下，Next.js 會預先渲染路由以提高效能，這稱為**靜態渲染 (Static Rendering)**。因此，如果您的資料發生變化，它不會反映在您的儀表板上。

我們將在本章討論第 1 點，然後在下一章詳細探討第 2 點。

## 什麼是請求瀑布 (Request Waterfalls)？

「瀑布」指的是一系列依賴於前一個請求完成的網路請求。在資料獲取的情況下，每個請求只有在前一個請求返回資料後才能開始。

![序列與平行資料獲取示意圖](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Flearn%2Fdark%2Fsequential-parallel-data-fetching.png&w=3840&q=75)

例如，我們需要等待 `fetchRevenue()` 執行完畢，`fetchLatestInvoices()` 才能開始運行，以此類推。

`/app/dashboard/page.tsx`

```tsx
const revenue = await fetchRevenue();
const latestInvoices = await fetchLatestInvoices(); // 等待 fetchRevenue() 完成
const {
  numberOfInvoices,
  numberOfCustomers,
  totalPaidInvoices,
  totalPendingInvoices,
} = await fetchCardData(); // 等待 fetchLatestInvoices() 完成
```

這種模式不一定不好。在某些情況下，您可能希望使用瀑布，因為您希望在發起下一個請求之前滿足某個條件。例如，您可能想先獲取使用者的 ID 和個人資料資訊。一旦有了 ID，您可能會接著獲取他們的朋友列表。在這種情況下，每個請求都依賴於前一個請求返回的資料。

然而，這種行為也可能是無意的，並會影響效能。

## 平行資料獲取

避免瀑布的一個常見方法是同時發起所有資料請求——即**平行 (in parallel)**。

在 JavaScript 中，您可以使用 `Promise.all()` 或 `Promise.allSettled()` 函數來同時發起所有 promises。例如，在 `data.ts` 中，我們在 `fetchCardData()` 函數中使用了 `Promise.all()`：

`/app/lib/data.ts`

```ts
export async function fetchCardData() {
  try {
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;

    const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);
    // ...
  }
}
```

通過使用這種模式，您可以：

- 同時開始執行所有資料獲取，這比在瀑布中等待每個請求完成要快。
- 使用一個可以應用於任何函式庫或框架的原生 JavaScript 模式。

然而，僅依賴這種 JavaScript 模式有一個缺點：如果其中一個資料請求比其他所有請求都慢，會發生什麼事？讓我們在下一章中詳細了解。
