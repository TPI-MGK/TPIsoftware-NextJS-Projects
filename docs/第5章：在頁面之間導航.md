# 第五章：在頁面之間導航

在上一章中，您建立了儀表板的版面配置和頁面。現在，讓我們添加一些連結，讓使用者能夠在儀表板的各個路由之間導航。

## 在本章中...

以下是我們將涵蓋的主題：

-   如何使用 `next/link` 元件。
-   如何使用 `usePathname()` hook 顯示當前活動連結。
-   Next.js 中的導航是如何運作的。

## 為何要優化導航？

若要在頁面之間建立連結，傳統上您會使用 `<a>` HTML 元素。目前，側邊欄的連結使用的是 `<a>` 元素，但請注意當您在瀏覽器中於首頁、發票頁和客戶頁之間導航時會發生什麼。

您看到了嗎？每次頁面導航都會有一次**完整的頁面刷新**！

## `<Link>` 元件

在 Next.js 中，您可以使用 `<Link />` 元件在應用程式的頁面之間建立連結。`<Link>` 允許您使用 JavaScript 進行**客戶端導航 (client-side navigation)**。

要使用 `<Link />` 元件，請開啟 `/app/ui/dashboard/nav-links.tsx`，從 `next/link` 匯入 `Link` 元件。然後，將 `<a>` 標籤替換為 `<Link>`：

`/app/ui/dashboard/nav-links.tsx`
```tsx
import {
  UserGroupIcon,
  HomeIcon,
  DocumentDuplicateIcon,
} from '@heroicons/react/24/outline';
import Link from 'next/link';

// ...

export default function NavLinks() {
  return (
    <>
      {links.map((link) => {
        const LinkIcon = link.icon;
        return (
          <Link
            key={link.name}
            href={link.href}
            className="flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3"
          >
            <LinkIcon className="w-6" />
            <p className="hidden md:block">{link.name}</p>
          </Link>
        );
      })}
    </>
  );
}
```

如您所見，`Link` 元件的使用方式與 `<a>` 標籤相似，但您使用的是 `<Link href="...">` 而不是 `<a href="...">`。

儲存您的變更並在您的 localhost 中檢查它是否正常運作。您現在應該能夠在頁面之間導航而不會看到完整的刷新。儘管您的應用程式的部分內容是在伺服器上渲染的，但沒有整頁刷新，使其感覺像一個原生的 Web 應用程式。這是為什麼呢？

### 自動的程式碼分割與預先載入

為了改善導航體驗，Next.js 會根據路由區段自動對您的應用程式進行**程式碼分割 (code splitting)**。這與傳統的 React SPA（單頁應用程式）不同，後者會在初始載入時讓瀏覽器載入所有應用程式的程式碼。

按路由分割程式碼意味著頁面變得相互隔離。如果某個頁面拋出錯誤，應用程式的其餘部分仍然可以運作。

此外，在生產環境中，每當 `<Link>` 元件出現在瀏覽器的可視範圍內時，Next.js 都會自動在背景**預先載入 (prefetch)** 所連結路由的程式碼。當使用者點擊連結時，目標頁面的程式碼已經在背景載入完畢，這就是為什麼頁面轉換幾乎是即時的！

您可以[了解更多關於導航如何運作](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#how-navigation-works)的資訊。

## 模式：顯示活動連結

一個常見的 UI 模式是顯示一個活動連結，以向使用者指示他們目前所在的頁面。要做到這一點，您需要從 URL 中獲取使用者當前的路徑。Next.js 提供了一個名為 `usePathname()` 的 hook，您可以使用它來檢查路徑並實現此模式。

由於 `usePathname()` 是一個 React hook，您需要將 `nav-links.tsx` 轉變為一個**客戶端元件 (Client Component)**。在檔案頂部添加 React 的 `"use client"` 指令，然後從 `next/navigation` 匯入 `usePathname()`：

`/app/ui/dashboard/nav-links.tsx`
```tsx
'use client';

import {
  UserGroupIcon,
  HomeIcon,
  DocumentDuplicateIcon,
} from '@heroicons/react/24/outline';
import Link from 'next/link';
import { usePathname } from 'next/navigation';

// ...
```

接下來，在您的 `<NavLinks />` 元件內部，將路徑賦值給一個名為 `pathname` 的變數：

`/app/ui/dashboard/nav-links.tsx`
```tsx
export default function NavLinks() {
  const pathname = usePathname();
  // ...
}
```

您可以使用在 CSS 樣式章節中介紹的 `clsx` 函式庫，在連結處於活動狀態時有條件地應用 class 名稱。當 `link.href` 與 `pathname` 相符時，連結應顯示為藍色文字和淺藍色背景。

以下是 `nav-links.tsx` 的最終程式碼：

`/app/ui/dashboard/nav-links.tsx`
```tsx
'use client';

import {
  UserGroupIcon,
  HomeIcon,
  DocumentDuplicateIcon,
} from '@heroicons/react/24/outline';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import clsx from 'clsx';

// ...

export default function NavLinks() {
  const pathname = usePathname();

  return (
    <>
      {links.map((link) => {
        const LinkIcon = link.icon;
        return (
          <Link
            key={link.name}
            href={link.href}
            className={clsx(
              'flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3',
              {
                'bg-sky-100 text-blue-600': pathname === link.href,
              },
            )}
          >
            <LinkIcon className="w-6" />
            <p className="hidden md:block">{link.name}</p>
          </Link>
        );
      })}
    </>
  );
}
```

儲存並檢查您的 localhost。您現在應該能看到活動連結以藍色高亮顯示。
```
