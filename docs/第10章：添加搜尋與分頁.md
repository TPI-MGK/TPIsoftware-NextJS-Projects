# 第十章：添加搜尋與分頁

在上一章中，您透過串流 (streaming) 改善了儀表板的初始載入效能。現在，讓我們轉到 `/invoices` 頁面，學習如何添加搜尋和分頁功能。

## 在本章中...

以下是我們將涵蓋的主題：

- 學習如何使用 Next.js 的 API：`useSearchParams`、`usePathname` 和 `useRouter`。
- 使用 URL 搜尋參數 (URL search params) 實現搜尋和分頁。

## 起始程式碼

在您的 `/app/dashboard/invoices/page.tsx` 檔案中，貼上以下程式碼：

`/app/dashboard/invoices/page.tsx`

```tsx
import Pagination from "@/app/ui/invoices/pagination";
import Search from "@/app/ui/search";
import Table from "@/app/ui/invoices/table";
import { CreateInvoice } from "@/app/ui/invoices/buttons";
import { lusitana } from "@/app/ui/fonts";
import { InvoicesTableSkeleton } from "@/app/ui/skeletons";
import { Suspense } from "react";

export default async function Page() {
  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      {/*  <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense> */}
      <div className="mt-5 flex w-full justify-center">
        {/* <Pagination totalPages={totalPages} /> */}
      </div>
    </div>
  );
}
```

花一些時間熟悉這個頁面以及您將使用的元件：

- `<Search/>` 允許使用者搜尋特定的發票。
- `<Pagination/>` 允許使用者在發票頁面之間導航。
- `<Table/>` 顯示發票列表。

您的搜尋功能將橫跨客戶端和伺服器。當使用者在客戶端搜尋發票時，URL 參數將被更新，資料將在伺服器上獲取，然後表格將使用新資料在伺服器上重新渲染。

## 為何使用 URL 搜尋參數？

如上所述，您將使用 URL 搜尋參數來管理搜尋狀態。如果您習慣於使用客戶端狀態來完成此操作，那麼這種模式可能對您來說是全新的。

使用 URL 參數實現搜尋有幾個好處：

- **可書籤和可共享的 URL**：由於搜尋參數包含在 URL 中，使用者可以為應用程式的當前狀態（包括他們的搜尋查詢和篩選條件）添加書籤，以便將來參考或分享。
- **伺服器端渲染**：URL 參數可以直接在伺服器上使用以渲染初始狀態，這使得處理伺服器渲染變得更容易。
- **分析和追蹤**：將搜尋查詢和篩選條件直接放入 URL 中，可以更容易地追蹤使用者行為，而無需額外的客戶端邏輯。

## 添加搜尋功能

這些是您將用於實現搜尋功能的 Next.js 客戶端 hook：

- `useSearchParams` - 允許您存取當前 URL 的參數。例如，對於 `/dashboard/invoices?page=1&query=pending` 這個 URL，搜尋參數會像這樣：`{page: '1', query: 'pending'}`。
- `usePathname` - 讓您讀取當前 URL 的路徑名稱 (pathname)。例如，對於 `/dashboard/invoices` 路由，`usePathname` 將返回 `'/dashboard/invoices'`。
- `useRouter` - 允許您在客戶端元件中以程式設計方式進行路由之間的導航。您可以使用多種方法。

以下是實作步驟的快速概覽：

1.  捕捉使用者的輸入。
2.  使用搜尋參數更新 URL。
3.  保持 URL 與輸入欄位同步。
4.  更新表格以反映搜尋查詢。

### 1. 捕捉使用者的輸入

進入 `<Search>` 元件 (`/app/ui/search.tsx`)，您會注意到：

- `"use client"` - 這是一個客戶端元件 (Client Component)，這意味著您可以使用事件監聽器和 hook。
- `<input>` - 這是搜尋輸入欄位。

建立一個新的 `handleSearch` 函數，並為 `<input>` 元素添加一個 `onChange` 監聽器。每當輸入值改變時，`onChange` 都會調用 `handleSearch`。

`/app/ui/search.tsx`

```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";

export default function Search({ placeholder }: { placeholder: string }) {
  function handleSearch(term: string) {
    console.log(term);
  }

  return (
    <div className="relative flex flex-1 shrink-0">
      <label htmlFor="search" className="sr-only">
        Search
      </label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(e) => {
          handleSearch(e.target.value);
        }}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}
```

透過在瀏覽器開發者工具中打開控制台，然後在搜尋欄位中輸入內容，來驗證它是否正常工作。您應該會看到搜尋詞被記錄到瀏覽器控制台。

太棒了！您正在捕捉使用者的搜尋輸入。現在，您需要使用搜尋詞來更新 URL。

### 2. 使用搜尋參數更新 URL

從 `next/navigation` 匯入 `useSearchParams` hook 並將其賦值給一個變數：

`/app/ui/search.tsx`

```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";
import { useSearchParams } from "next/navigation";

export default function Search() {
  const searchParams = useSearchParams();

  function handleSearch(term: string) {
    console.log(term);
  }
  // ...
}
```

在 `handleSearch` 內部，使用您的新 `searchParams` 變數建立一個新的 `URLSearchParams` 實例。

`/app/ui/search.tsx`

```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";
import { useSearchParams } from "next/navigation";

export default function Search() {
  const searchParams = useSearchParams();

  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams);
  }
  // ...
}
```

`URLSearchParams` 是一個 Web API，它提供了操作 URL 查詢參數的實用方法。您可以使用它來獲取像 `?page=1&query=a` 這樣的參數字串，而不是建立複雜的字串字面量。

接下來，根據使用者的輸入設定參數字串。如果輸入為空，您需要將其刪除：

`/app/ui/search.tsx`

```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";
import { useSearchParams } from "next/navigation";

export default function Search() {
  const searchParams = useSearchParams();

  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams);
    if (term) {
      params.set("query", term);
    } else {
      params.delete("query");
    }
  }
  // ...
}
```

現在您有了查詢字串。您可以使用 Next.js 的 `useRouter` 和 `usePathname` hook 來更新 URL。

從 `next/navigation` 匯入 `useRouter` 和 `usePathname`，並在 `handleSearch` 內部使用 `useRouter()` 的 `replace` 方法：

`/app/ui/search.tsx`

```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";
import { useSearchParams, usePathname, useRouter } from "next/navigation";

export default function Search() {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams);
    if (term) {
      params.set("query", term);
    } else {
      params.delete("query");
    }
    replace(`${pathname}?${params.toString()}`);
  }
}
```

以下是正在發生的情況的細分：

- `${pathname}` 是當前路徑，在您的情況下是 `"/dashboard/invoices"`。
- 當使用者在搜尋欄中輸入時，`params.toString()` 會將此輸入轉換為 URL 友好的格式。
- `replace(`${pathname}?${params.toString()}`)` 會使用使用者的搜尋資料更新 URL。例如，如果使用者搜尋「Lee」，則 URL 會變成 `/dashboard/invoices?query=lee`。
- 由於 Next.js 的客戶端導航（您在關於[頁面之間導航](https://nextjs.org/learn/dashboard-app/navigating-between-pages)的章節中學過），URL 會在不重新載入頁面的情況下更新。

### 3. 保持 URL 與輸入同步

為了確保輸入欄位與 URL 同步，並在共享時能被填充，您可以透過從 `searchParams` 讀取來向 `input` 傳遞一個 `defaultValue`：

`/app/ui/search.tsx`

```tsx
<input
  className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
  placeholder={placeholder}
  onChange={(e) => {
    handleSearch(e.target.value);
  }}
  defaultValue={searchParams.get("query")?.toString()}
/>
```

#### `defaultValue` vs. `value` / 受控元件 vs. 非受控元件

如果您使用狀態來管理輸入的值，您會使用 `value` 屬性使其成為受控元件 (controlled component)。這表示 React 將管理輸入的狀態。

然而，由於您沒有使用狀態，因此可以使用 `defaultValue`。這表示原生的 `input` 將管理其自己的狀態。這是可以的，因為您正在將搜尋查詢儲存到 URL 而不是狀態中。

### 4. 更新表格

最後，您需要更新表格元件以反映搜尋查詢。

1.  回到發票頁面 (`/app/dashboard/invoices/page.tsx`)。
2.  頁面元件接受一個名為 `searchParams` 的屬性 (prop)，因此您可以將當前 URL 參數傳遞給 `<Table>` 元件。

`/app/dashboard/invoices/page.tsx`

```tsx
import Pagination from "@/app/ui/invoices/pagination";
import Search from "@/app/ui/search";
import Table from "@/app/ui/invoices/table";
import { CreateInvoice } from "@/app/ui/invoices/buttons";
import { lusitana } from "@/app/ui/fonts";
import { Suspense } from "react";
import { InvoicesTableSkeleton } from "@/app/ui/skeletons";

export default async function Page(props: {
  searchParams?: {
    query?: string;
    page?: string;
  };
}) {
  const query = props.searchParams?.query || "";
  const currentPage = Number(props.searchParams?.page) || 1;

  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense>
      <div className="mt-5 flex w-full justify-center">
        {/* <Pagination totalPages={totalPages} /> */}
      </div>
    </div>
  );
}
```

如果您導航到 `<Table>` 元件，您會看到 `query` 和 `currentPage` 這兩個 props 被傳遞給 `fetchFilteredInvoices()` 函數，該函數會返回符合查詢條件的發票。

`/app/ui/invoices/table.tsx`

```tsx
// ...
export default async function InvoicesTable({
  query,
  currentPage,
}: {
  query: string;
  currentPage: number;
}) {
  const invoices = await fetchFilteredInvoices(query, currentPage);
  // ...
}
```

這些變更到位後，請繼續測試它。如果您搜尋一個詞，您將更新 URL，這會向伺服器發送一個新請求，資料將在伺服器上獲取，並且只會返回符合您查詢條件的發票。

### 何時使用 `useSearchParams()` hook 與 `searchParams` 屬性？

您可能已經注意到您使用了兩種不同的方式來提取搜尋參數。使用哪種方式取決於您是在客戶端還是在伺服器上工作。

- `<Search>` 是一個客戶端元件 (Client Component)，因此您使用 `useSearchParams()` hook 從客戶端存取參數。
- `<Table>` 是一個伺服器元件 (Server Component)，它獲取自己的資料，因此您可以將 `searchParams` 屬性從頁面傳遞給元件。

一般來說，如果您想從客戶端讀取參數，請使用 `useSearchParams()` hook，因為這可以避免回到伺服器。

### 最佳實踐：防抖動 (Debouncing)

恭喜！您已經使用 Next.js 實現了搜尋功能！但您可以做一些事情來優化它。

在您的 `handleSearch` 函數內部，添加以下 `console.log`：

`/app/ui/search.tsx`

```tsx
function handleSearch(term: string) {
  console.log(`Searching... ${term}`);

  const params = new URLSearchParams(searchParams);
  if (term) {
    params.set("query", term);
  } else {
    params.delete("query");
  }
  replace(`${pathname}?${params.toString()}`);
}
```

然後在您的搜尋欄中輸入「Delba」，並檢查開發者工具中的控制台。發生了什麼事？

```
Dev Tools Console
Searching... D
Searching... De
Searching... Del
Searching... Delb
Searching... Delba
```

您在每次按鍵時都在更新 URL，因此在每次按鍵時都在查詢您的資料庫！這在我們的應用程式很小的時候不是問題，但想像一下如果您的應用程式有成千上萬的使用者，每個使用者在每次按鍵時都向您的資料庫發送新請求。

**防抖動 (Debouncing)** 是一種程式設計實踐，它限制了函數觸發的頻率。在我們的案例中，您只想在使用者停止輸入後才查詢資料庫。

#### 防抖動的工作原理：

- **觸發事件**：當一個應該被防抖動的事件發生時（例如在搜尋框中按鍵），計時器開始計時。
- **等待**：如果在計時器到期之前發生新事件，計時器將被重置。
- **執行**：如果計時器完成倒計時，防抖動函數將被執行。

您可以透過幾種方式實現防抖動，包括手動創建自己的防抖動函數。為了簡化問題，我們將使用一個名為 `use-debounce` 的函式庫。

安裝 `use-debounce`：

```bash
pnpm i use-debounce
```

在您的 `<Search>` 元件中，匯入一個名為 `useDebouncedCallback` 的函數：

`/app/ui/search.tsx`

```tsx
// ...
import { useDebouncedCallback } from "use-debounce";

// 在 Search 元件內部...
const handleSearch = useDebouncedCallback((term) => {
  console.log(`Searching... ${term}`);

  const params = new URLSearchParams(searchParams);
  if (term) {
    params.set("query", term);
  } else {
    params.delete("query");
  }
  replace(`${pathname}?${params.toString()}`);
}, 300);
```

這個函數將包裹 `handleSearch` 的內容，並且只會在使用者停止輸入後（300 毫秒後）運行程式碼。

現在再次在您的搜尋欄中輸入，並打開開發者工具中的控制台。您應該會看到以下內容：

```
Dev Tools Console
Searching... Delba
```

透過防抖動，您可以減少發送到資料庫的請求數量，從而節省資源。

## 添加分頁

在引入搜尋功能後，您會注意到表格每次只顯示 6 條發票。這是因為 `data.ts` 中的 `fetchFilteredInvoices()` 函數每頁最多返回 6 條發票。

添加分頁功能允許使用者瀏覽不同頁面以查看所有發票。讓我們看看如何使用 URL 參數實現分頁，就像您使用搜尋功能一樣。

導航到 `<Pagination/>` 元件，您會注意到它是一個客戶端元件 (Client Component)。您不希望在客戶端獲取資料，因為這會暴露您的資料庫密鑰（請記住，您沒有使用 API 層）。相反，您可以在伺服器上獲取資料，並將其作為 prop 傳遞給元件。

在 `/app/dashboard/invoices/page.tsx` 中，匯入一個名為 `fetchInvoicesPages` 的新函數，並將 `searchParams` 中的 `query` 作為參數傳遞：

`/app/dashboard/invoices/page.tsx`

```tsx
// ...
import { fetchInvoicesPages } from '@/app/lib/data';

export default async function Page(
  props: {
    searchParams?: {
      query?: string;
      page?: string;
    };
  }
) {
  const query = props.searchParams?.query || '';
  const currentPage = Number(props.searchParams?.page) || 1;
  const totalPages = await fetchInvoicesPages(query);

  return (
    // ...
  );
}
```

`fetchInvoicesPages` 會根據搜尋查詢返回總頁數。例如，如果共有 12 筆發票符合搜尋查詢，並且每頁顯示 6 筆發票，那麼總頁數將是 2。

接下來，將 `totalPages` 屬性傳遞給 `<Pagination/>` 元件：

`/app/dashboard/invoices/page.tsx`

```tsx
// ...

export default async function Page(props: {
  searchParams?: {
    query?: string;
    page?: string;
  };
}) {
  const query = props.searchParams?.query || "";
  const currentPage = Number(props.searchParams?.page) || 1;
  const totalPages = await fetchInvoicesPages(query);

  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense>
      <div className="mt-5 flex w-full justify-center">
        <Pagination totalPages={totalPages} />
      </div>
    </div>
  );
}
```

導航到 `<Pagination/>` 元件並匯入 `usePathname` 和 `useSearchParams` hook。我們將使用這些 hook 來獲取當前頁面並設定新頁面。請確保也取消此元件中的程式碼註解。您的應用程式會暫時無法使用，因為您尚未實現 `<Pagination/>` 的邏輯。現在就來實現它！

`/app/ui/invoices/pagination.tsx`

```tsx
"use client";

import { ArrowLeftIcon, ArrowRightIcon } from "@heroicons/react/24/outline";
import clsx from "clsx";
import Link from "next/link";
import { generatePagination } from "@/app/lib/utils";
import { usePathname, useSearchParams } from "next/navigation";

export default function Pagination({ totalPages }: { totalPages: number }) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const currentPage = Number(searchParams.get("page")) || 1;

  // ...
}
```

接下來，在 `<Pagination>` 元件內部建立一個名為 `createPageURL` 的新函數。與搜尋類似，您將使用 `URLSearchParams` 來設定新的頁碼，並使用 `pathname` 來建立 URL 字串。

`/app/ui/invoices/pagination.tsx`

```tsx
'use client';

import { ArrowLeftIcon, ArrowRightIcon } from '@heroicons/react/24/outline';
import clsx from 'clsx';
import Link from 'next/link';
import { generatePagination } from '@/app/lib/utils';
import { usePathname, useSearchParams } => from 'next/navigation';

export default function Pagination({ totalPages }: { totalPages: number }) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const currentPage = Number(searchParams.get('page')) || 1;

  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `${pathname}?${params.toString()}`;
  };

  // ...
}
```

以下是正在發生的事情的細分：

- `createPageURL` 建立當前搜尋參數的一個實例。
- 然後，它將「page」參數更新為提供的頁碼。
- 最後，它使用 `pathname` 和更新後的搜尋參數構建完整的 URL。

`<Pagination>` 元件的其餘部分涉及樣式和不同的狀態（第一頁、最後一頁、活動頁面、禁用等）。我們不會在本課程中深入探討，但請隨意瀏覽程式碼，看看 `createPageURL` 是在哪裡被調用的。

最後，當使用者輸入新的搜尋查詢時，您希望將頁碼重設為 1。您可以透過更新 `<Search>` 元件中的 `handleSearch` 函數來實現此功能：

`/app/ui/search.tsx`

```tsx
'use client';

import { MagnifyingGlassIcon } from '@heroicons/react/24/outline';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { useDebouncedCallback } from 'use-debounce';

export default function Search({ placeholder }: { placeholder: string }) {
  const searchParams = useSearchParams();
  const { replace } = useRouter();
  const pathname = usePathname();

  const handleSearch = useDebouncedCallback((term) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', '1'); // 在新的搜尋查詢時重設頁碼
    if (term) {
      params.set('query', term);
    } else {
      params.delete('query');
    }
    replace(`${pathname}?${params.toString()}`);
  }, 300);
```

## 總結

恭喜！您剛剛使用 URL 搜尋參數和 Next.js API 實現了搜尋和分頁功能。

總結來說，在本章中：

- 您使用 URL 搜尋參數而非客戶端狀態處理了搜尋和分頁。
- 您在伺服器上獲取了資料。
- 您使用了 `useRouter` 路由 hook 進行更流暢的客戶端轉換。

這些模式與您在客戶端 React 中可能習慣的有所不同，但希望您現在能更好地理解使用 URL 搜尋參數並將此狀態提升到伺服器的好處。

```

```
