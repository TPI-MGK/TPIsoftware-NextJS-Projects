# 第八章：靜態與動態渲染

在上一章中，您為儀表板概覽頁面獲取了資料。然而，我們簡要討論了當前設置的兩個局限性：

1.  資料請求產生了無意的請求瀑布 (waterfall)。
2.  儀表板是靜態的，因此任何資料更新都不會反映在您的應用程式中。

## 在本章中...

以下是我們將涵蓋的主題：

-   什麼是靜態渲染 (Static Rendering) 及其如何提升應用程式效能。
-   什麼是動態渲染 (Dynamic Rendering) 及其使用時機。
-   讓您的儀表板變為動態的不同方法。
-   模擬一個緩慢的資料獲取，看看會發生什麼。

## 什麼是靜態渲染 (Static Rendering)？

使用**靜態渲染**，資料獲取和渲染會在**建置時**（當您部署時）或重新驗證資料時在伺服器上進行。

每當使用者訪問您的應用程式時，都會提供快取的結果。靜態渲染有幾個好處：

-   **更快的網站** - 預先渲染的內容可以被快取並在部署到像 Vercel 這樣的平台時進行全球分發。這確保了世界各地的使用者可以更快、更可靠地存取您網站的內容。
-   **減少伺服器負載** - 因為內容是快取的，您的伺服器不必為每個使用者請求動態生成內容。這可以降低運算成本。
-   **SEO** - 預先渲染的內容更容易被搜尋引擎爬蟲索引，因為頁面載入時內容就已經可用。這有助於提高搜尋引擎排名。

靜態渲染適用於沒有資料或資料在使用者之間共享的 UI，例如靜態部落格文章或產品頁面。對於具有定期更新的個人化資料的儀表板來說，這可能不是一個好的選擇。

靜態渲染的對立面是動態渲染。

## 什麼是動態渲染 (Dynamic Rendering)？

使用**動態渲染**，內容會在**請求時**（當使用者訪問頁面時）為每個使用者在伺服器上渲染。動態渲染有幾個好處：

-   **即時資料** - 動態渲染允許您的應用程式顯示即時或頻繁更新的資料。這對於資料經常變動的應用程式非常理想。
-   **使用者特定內容** - 更容易提供個人化內容，例如儀表板或使用者個人資料，並根據使用者互動更新資料。
-   **請求時資訊** - 動態渲染允許您存取只能在請求時才能知道的資訊，例如 cookies 或 URL 搜尋參數。

## 模擬緩慢的資料獲取

我們正在建構的儀表板應用程式是動態的。

然而，上一章中提到的一個問題仍然存在：如果一個資料請求比所有其他請求都慢，會發生什麼？

讓我們模擬一次緩慢的資料獲取。在 `app/lib/data.ts` 中，取消 `fetchRevenue()` 函數內部 `console.log` 和 `setTimeout` 的註解：

`/app/lib/data.ts`
```ts
export async function fetchRevenue() {
  try {
    // 為了示範，我們人為地延遲了回應。
    // 請不要在生產環境中這樣做 :)
    console.log('Fetching revenue data...');
    await new Promise((resolve) => setTimeout(resolve, 3000));
 
    const data = await sql<Revenue[]>`SELECT * FROM revenue`;
 
    console.log('Data fetch completed after 3 seconds.');
 
    return data;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch revenue data.');
  }
}
```

現在，在新分頁中開啟 `http://localhost:3000/dashboard/`，並注意頁面載入時間變長了。在您的終端機中，您應該也會看到以下訊息：

```bash
Fetching revenue data...
Data fetch completed after 3 seconds.
```

在這裡，您添加了一個人為的 3 秒延遲來模擬緩慢的資料獲取。結果是，現在您的整個頁面在獲取資料時都被阻塞，無法向訪客顯示 UI。這就引出了一個開發者必須解決的常見挑戰：

**使用動態渲染時，您的應用程式速度取決於您最慢的資料獲取速度。**
