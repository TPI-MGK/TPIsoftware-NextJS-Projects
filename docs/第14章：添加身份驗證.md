# 第十四章：添加身份驗證

在上一章中，您透過添加表單驗證和改善可及性，完成了發票路由的建構。在本章中，您將為您的儀表板添加身份驗證功能。

## 在本章中...

以下是我們將涵蓋的主題：

-   什麼是身份驗證 (authentication)。
-   如何使用 NextAuth.js 為您的應用程式添加身份驗證。
-   如何使用中介軟體 (Middleware) 來重新導向使用者並保護您的路由。
-   如何使用 React 的 `useActionState` 來處理待處理狀態和表單錯誤。

## 什麼是身份驗證 (Authentication)？

身份驗證是當今許多 Web 應用程式的關鍵部分。它是系統用來檢查使用者是否如其所聲稱的身分的方式。

一個安全的網站通常會使用多種方式來檢查使用者的身份。例如，在輸入您的使用者名稱和密碼後，網站可能會向您的設備發送一個驗證碼，或使用像 Google Authenticator 這樣的外部應用程式。這種**雙重認證 (2-factor authentication, 2FA)** 有助於提高安全性。即使有人知道了您的密碼，沒有您的唯一權杖，他們也無法存取您的帳戶。

### 身份驗證 (Authentication) vs. 授權 (Authorization)

在 Web 開發中，身份驗證和授權扮演著不同的角色：

-   **身份驗證**是確保使用者是他們所聲稱的身份。您用您擁有的東西（如使用者名稱和密碼）來證明您的身份。
-   **授權**是下一步。一旦使用者的身份被確認，授權決定了他們被允許使用應用程式的哪些部分。

所以，身份驗證檢查**您是誰**，而授權決定了您在應用程式中**可以做什麼**或**存取什麼**。

## 建立登入路由

首先，在您的應用程式中建立一個名為 `/login` 的新路由，並貼上以下程式碼：

`/app/login/page.tsx`
```tsx
import AcmeLogo from '@/app/ui/acme-logo';
import LoginForm from '@/app/ui/login-form';
import { Suspense } from 'react';
 
export default function LoginPage() {
  return (
    <main className="flex items-center justify-center md:h-screen">
      <div className="relative mx-auto flex w-full max-w-[400px] flex-col space-y-2.5 p-4 md:-mt-32">
        <div className="flex h-20 w-full items-end rounded-lg bg-blue-500 p-3 md:h-36">
          <div className="w-32 text-white md:w-36">
            <AcmeLogo />
          </div>
        </div>
        <Suspense>
          <LoginForm />
        </Suspense>
      </div>
    </main>
  );
}
```

您會注意到頁面匯入了 `<LoginForm />`，您將在本章稍後更新它。這個元件被 React 的 `<Suspense>` 包裹，因為它將存取來自傳入請求的資訊（URL 搜尋參數）。

## NextAuth.js

我們將使用 **NextAuth.js** 為您的應用程式添加身份驗證。NextAuth.js 抽象化了管理會話、登入和登出以及身份驗證其他方面所涉及的大部分複雜性。雖然您可以手動實現這些功能，但這個過程可能耗時且容易出錯。NextAuth.js 簡化了這個過程，為 Next.js 應用程式中的身份驗證提供了一個統一的解決方案。

### 設定 NextAuth.js

在您的終端機中運行以下指令來安裝 NextAuth.js：

```bash
pnpm i next-auth@beta
```
您正在安裝的是與 Next.js 14+ 相容的 `next-auth` 的測試版。

接下來，為您的應用程式生成一個密鑰。這個密鑰用於加密 cookies，確保使用者會話的安全性。您可以在終端機中運行以下指令來完成：

```bash
# macOS
openssl rand -base64 32
# Windows 可以使用 https://generate-secret.vercel.app/32
```

然後，在您的 `.env` 檔案中，將您生成的密鑰添加到 `AUTH_SECRET` 變數中：

`.env`
```
AUTH_SECRET=your-secret-key
```

為了讓身份驗證在生產環境中正常工作，您還需要在您的 Vercel 專案中更新您的環境變數。

### 添加 `pages` 選項

在您專案的根目錄中建立一個名為 `auth.config.ts` 的檔案，它將導出一個 `authConfig` 物件。這個物件將包含 NextAuth.js 的配置選項。目前，它只會包含 `pages` 選項：

`/auth.config.ts`
```ts
import type { NextAuthConfig } from 'next-auth';
 
export const authConfig = {
  pages: {
    signIn: '/login',
  },
} satisfies NextAuthConfig;
```

您可以使用 `pages` 選項來指定自訂登入、登出和錯誤頁面的路由。這不是必需的，但通過將 `signIn: '/login'` 添加到我們的 `pages` 選項中，使用者將被重新導向到我們的自訂登入頁面，而不是 NextAuth.js 的預設頁面。

### 使用 Next.js 中介軟體保護您的路由

接下來，添加保護您路由的邏輯。這將阻止使用者存取儀表板頁面，除非他們已登入。

`/auth.config.ts`
```ts
import type { NextAuthConfig } from 'next-auth';
 
export const authConfig = {
  pages: {
    signIn: '/login',
  },
  callbacks: {
    authorized({ auth, request: { nextUrl } }) {
      const isLoggedIn = !!auth?.user;
      const isOnDashboard = nextUrl.pathname.startsWith('/dashboard');
      if (isOnDashboard) {
        if (isLoggedIn) return true;
        return false; // 將未驗證的使用者重新導向到登入頁面
      } else if (isLoggedIn) {
        return Response.redirect(new URL('/dashboard', nextUrl));
      }
      return true;
    },
  },
  providers: [], // 暫時添加一個空陣列
} satisfies NextAuthConfig;
```

-   `authorized` 回呼函數用於驗證請求是否有權限通過 Next.js 中介軟體存取頁面。它在請求完成之前被呼叫，並接收一個帶有 `auth` 和 `request` 屬性的物件。`auth` 屬性包含使用者的會話，而 `request` 屬性包含傳入的請求。
-   `providers` 選項是您列出不同登入選項的陣列。目前，它是一個空陣列以滿足 NextAuth 的配置。

接下來，您需要將 `authConfig` 物件匯入到一個中介軟體檔案中。在您專案的根目錄中，建立一個名為 `middleware.ts` 的檔案並貼上以下程式碼：

`/middleware.ts`
```ts
import NextAuth from 'next-auth';
import { authConfig } from './auth.config';
 
export default NextAuth(authConfig).auth;
 
export const config = {
  // https://nextjs.org/docs/app/api-reference/file-conventions/middleware#matcher
  matcher: ['/((?!api|_next/static|_next/image|.*\.png$).*)'],
};
```
在這裡，您使用 `authConfig` 物件初始化 NextAuth.js 並導出 `auth` 屬性。您還使用了來自中介軟體的 `matcher` 選項來指定它應該在特定的路徑上運行。

使用中介軟體來完成此任務的優點是，受保護的路由甚至在**中介軟體驗證身份之前不會開始渲染**，從而增強了您應用程式的安全性和效能。

### 密碼雜湊

在將密碼儲存到資料庫之前對其進行雜湊處理是一個好習慣。雜湊將密碼轉換為一個固定長度的字元串，看起來是隨機的，即使使用者的資料被洩露，也提供了一層安全保障。

在填充資料庫時，您使用了一個名為 `bcrypt` 的套件來雜湊使用者的密碼。您將在本章稍後再次使用它，以比較使用者輸入的密碼是否與資料庫中的密碼相符。然而，您需要為 `bcrypt` 套件創建一個單獨的檔案。這是因為 `bcrypt` 依賴於 Next.js 中介軟體中不可用的 Node.js API。

建立一個名為 `auth.ts` 的新檔案，它將展開您的 `authConfig` 物件：

`/auth.ts`
```ts
import NextAuth from 'next-auth';
import { authConfig } from './auth.config';
 
export const { auth, signIn, signOut } = NextAuth({
  ...authConfig,
});
```

### 添加 Credentials 提供者

接下來，您需要為 NextAuth.js 添加 `providers` 選項。`providers` 是一個陣列，您可以在其中列出不同的登入選項，如 Google 或 GitHub。在本課程中，我們將僅專注於使用 **Credentials** 提供者。

Credentials 提供者允許使用者使用使用者名稱和密碼登入。

`/auth.ts`
```ts
import NextAuth from 'next-auth';
import { authConfig } from './auth.config';
import Credentials from 'next-auth/providers/credentials';
 
export const { auth, signIn, signOut } = NextAuth({
  ...authConfig,
  providers: [Credentials({})],
});
```

> **值得注意的是**：還有其他替代提供者，如 OAuth 或 email。有關選項的完整列表，請參閱 [NextAuth.js 文件](https://next-auth.js.org/providers)。

### 添加登入功能

您可以使用 `authorize` 函數來處理身份驗證邏輯。與 Server Actions 類似，您可以使用 `zod` 來驗證電子郵件和密碼，然後再檢查使用者是否存在於資料庫中：

`/auth.ts`
```ts
import NextAuth from 'next-auth';
import { authConfig } from './auth.config';
import Credentials from 'next-auth/providers/credentials';
import { z } from 'zod';
 
export const { auth, signIn, signOut } = NextAuth({
  ...authConfig,
  providers: [
    Credentials({
      async authorize(credentials) {
        const parsedCredentials = z
          .object({ email: z.string().email(), password: z.string().min(6) })
          .safeParse(credentials);
      },
    }),
  ],
});
```

驗證憑證後，建立一個新的 `getUser` 函數，從資料庫中查詢使用者。

`/auth.ts`
```ts
import NextAuth from 'next-auth';
import Credentials from 'next-auth/providers/credentials';
import { authConfig } from './auth.config';
import { z } from 'zod';
import type { User } from '@/app/lib/definitions';
import bcrypt from 'bcrypt';
import postgres from 'postgres';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
 
async function getUser(email: string): Promise<User | undefined> {
  try {
    const user = await sql<User[]>`SELECT * FROM users WHERE email=${email}`;
    return user[0];
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw new Error('Failed to fetch user.');
  }
}
 
export const { auth, signIn, signOut } = NextAuth({
  ...authConfig,
  providers: [
    Credentials({
      async authorize(credentials) {
        const parsedCredentials = z
          .object({ email: z.string().email(), password: z.string().min(6) })
          .safeParse(credentials);
 
        if (parsedCredentials.success) {
          const { email, password } = parsedCredentials.data;
          const user = await getUser(email);
          if (!user) return null;
        }
 
        return null;
      },
    }),
  ],
});
```

然後，呼叫 `bcrypt.compare` 來檢查密碼是否匹配：

`/auth.ts`
```ts
// ...
export const { auth, signIn, signOut } = NextAuth({
  ...authConfig,
  providers: [
    Credentials({
      async authorize(credentials) {
        // ...
 
        if (parsedCredentials.success) {
          const { email, password } = parsedCredentials.data;
          const user = await getUser(email);
          if (!user) return null;
          const passwordsMatch = await bcrypt.compare(password, user.password);
 
          if (passwordsMatch) return user;
        }
 
        console.log('Invalid credentials');
        return null;
      },
    }),
  ],
});
```

最後，如果密碼匹配，您希望返回使用者，否則，返回 `null` 以阻止使用者登入。

## 更新登入表單

現在您需要將身份驗證邏輯與您的登入表單連接起來。在您的 `actions.ts` 檔案中，創建一個名為 `authenticate` 的新 action。此 action 應從 `auth.ts` 匯入 `signIn` 函數：

`/app/lib/actions.ts`
```ts
'use server';
 
import { signIn } from '@/auth';
import { AuthError } from 'next-auth';
 
// ...
 
export async function authenticate(
  prevState: string | undefined,
  formData: FormData,
) {
  try {
    await signIn('credentials', formData);
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.';
        default:
          return 'Something went wrong.';
      }
    }
    throw error;
  }
}
```

如果出現 `'CredentialsSignin'` 錯誤，您希望顯示一條適當的錯誤訊息。您可以在 [NextAuth.js 文件](https://errors.nextjs.org/fr/adapter/next-auth)中了解更多關於 NextAuth.js 錯誤的資訊。

最後，在您的 `login-form.tsx` 元件中，您可以使用 React 的 `useActionState` 來呼叫 server action、處理表單錯誤並顯示表單的待處理狀態：

`/app/ui/login-form.tsx`
```tsx
'use client';
 
import { lusitana } from '@/app/ui/fonts';
import {
  AtSymbolIcon,
  KeyIcon,
  ExclamationCircleIcon,
} from '@heroicons/react/24/outline';
import { ArrowRightIcon } from '@heroicons/react/20/solid';
import { Button } from '@/app/ui/button';
import { useActionState } from 'react';
import { authenticate } from '@/app/lib/actions';
import { useSearchParams } from 'next/navigation';
 
export default function LoginForm() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/dashboard';
  const [errorMessage, formAction, isPending] = useActionState(
    authenticate,
    undefined,
  );
 
  return (
    <form action={formAction} className="space-y-3">
      <div className="flex-1 rounded-lg bg-gray-50 px-6 pb-4 pt-8">
        <h1 className={`${lusitana.className} mb-3 text-2xl`}>
          Please log in to continue.
        </h1>
        <div className="w-full">
          {/* ... email and password inputs */}
        </div>
        <input type="hidden" name="redirectTo" value={callbackUrl} />
        <Button className="mt-4 w-full" aria-disabled={isPending}>
          Log in <ArrowRightIcon className="ml-auto h-5 w-5 text-gray-50" />
        </Button>
        <div
          className="flex h-8 items-end space-x-1"
          aria-live="polite"
          aria-atomic="true"
        >
          {errorMessage && (
            <>
              <ExclamationCircleIcon className="h-5 w-5 text-red-500" />
              <p className="text-sm text-red-500">{errorMessage}</p>
            </>
          )}
        </div>
      </div>
    </form>
  );
}
```

## 添加登出功能

要將登出功能添加到 `<SideNav />`，請在您的 `<form>` 元素中呼叫 `auth.ts` 中的 `signOut` 函數：

`/app/ui/dashboard/sidenav.tsx`
```tsx
import Link from 'next/link';
import NavLinks from '@/app/ui/dashboard/nav-links';
import AcmeLogo from '@/app/ui/acme-logo';
import { PowerIcon } from '@heroicons/react/24/outline';
import { signOut } from '@/auth';
 
export default function SideNav() {
  return (
    <div className="flex h-full flex-col px-3 py-4 md:px-2">
      {/* ... */}
      <div className="flex grow flex-row justify-between space-x-2 md:flex-col md:space-x-0 md:space-y-2">
        <NavLinks />
        <div className="hidden h-auto w-full grow rounded-md bg-gray-50 md:block"></div>
        <form
          action={async () => {
            'use server';
            await signOut({ redirectTo: '/' });
          }}
        >
          <button className="flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3">
            <PowerIcon className="w-6" />
            <div className="hidden md:block">Sign Out</div>
          </button>
        </form>
      </div>
    </div>
  );
}
```

## 試用一下

現在，試試看。您應該能夠使用以下憑證登入和登出您的應用程式：

-   **電子郵件**: `user@nextmail.com`
-   **密碼**: `123456`