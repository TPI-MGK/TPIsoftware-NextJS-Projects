# 第十一章：修改資料

在上一章中，您使用 URL 搜尋參數和 Next.js API 實現了搜尋和分頁。現在，讓我們繼續處理發票頁面，學習如何添加創建、更新和刪除發票的功能！

## 在本章中...

以下是我們將涵蓋的主題：

-   什麼是 React Server Actions 以及如何使用它們來修改資料。
-   如何處理表單和伺服器元件。
-   使用原生 `FormData` 物件的最佳實踐，包括型別驗證。
-   如何使用 `revalidatePath` API 來重新驗證客戶端快取。
-   如何使用特定 ID 建立動態路由區段。

## 什麼是 Server Actions？

React Server Actions 允許您直接在伺服器上執行非同步程式碼。它們消除了為修改資料而建立 API 端點的需求。取而代之的是，您編寫在伺服器上執行的非同步函數，這些函數可以從您的客戶端或伺服器元件中調用。

安全性是 Web 應用程式的首要任務，因為它們可能受到各種威脅的攻擊。這就是 Server Actions 的用武之地。它們包含加密閉包、嚴格的輸入檢查、錯誤訊息雜湊、主機限制等功能——所有這些共同作用，顯著增強了您的應用程式安全性。

### 將表單與 Server Actions 一起使用

在 React 中，您可以在 `<form>` 元素中使用 `action` 屬性來調用 actions。該 action 將自動接收包含所捕獲資料的原生 `FormData` 物件。

例如：
```tsx
// 伺服器元件 (Server Component)
export default function Page() {
  // Action
  async function create(formData: FormData) {
    'use server';
 
    // 修改資料的邏輯...
  }
 
  // 使用 "action" 屬性調用 action
  return <form action={create}>...</form>;
}
```
在伺服器元件中調用 Server Action 的一個優點是**漸進式增強 (progressive enhancement)** ——即使客戶端的 JavaScript 尚未載入，表單也能正常工作。

### Next.js 與 Server Actions
Server Actions 也與 Next.js 的快取機制深度整合。當透過 Server Action 提交表單時，您不僅可以使用 action 來修改資料，還可以使用像 `revalidatePath` 和 `revalidateTag` 這樣的 API 來重新驗證相關的快取。

讓我們看看它們是如何一起運作的！

## 創建發票

以下是您創建新發票將採取的步驟：
1.  建立一個表單以捕捉使用者輸入。
2.  建立一個 Server Action 並從表單中調用它。
3.  在您的 Server Action 內部，從 `formData` 物件中提取資料。
4.  驗證並準備要插入到資料庫中的資料。
5.  插入資料並處理任何錯誤。
6.  重新驗證快取並將使用者重新導向回發票頁面。

### 1. 建立新路由和表單

首先，在 `/invoices` 資料夾內，添加一個名為 `/create` 的新路由區段，並附帶一個 `page.tsx` 檔案：

![創建發票路由](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Flearn%2Fdark%2Fcreate-invoice-route.png&w=3840&q=75)

您將使用此路由來創建新發票。在您的 `page.tsx` 檔案內，貼上以下程式碼，然後花些時間研究它：

`/dashboard/invoices/create/page.tsx`
```tsx
import Form from '@/app/ui/invoices/create-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  const customers = await fetchCustomers();
 
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Create Invoice',
            href: '/dashboard/invoices/create',
            active: true,
          },
        ]}
      />
      <Form customers={customers} />
    </main>
  );
}
```

您的頁面是一個伺服器元件，它獲取客戶列表並將其傳遞給 `<Form>` 元件。為了節省時間，我們已經為您創建了 `<Form>` 元件。

導航到 `<Form>` 元件，您會看到該表單：
-   有一個 `<select>` (下拉) 元素，包含客戶列表。
-   有一個 `<input>` 元素用於金額，`type="number"`。
-   有兩個 `<input>` 元素用於狀態，`type="radio"`。
-   有一個按鈕，`type="submit"`。

在 `http://localhost:3000/dashboard/invoices/create`，您應該會看到以下 UI。

### 2. 建立 Server Action

很好，現在讓我們建立一個將在提交表單時調用的 Server Action。

導航到您的 `lib/` 目錄並建立一個名為 `actions.ts` 的新檔案。在此檔案的頂部，添加 React 的 `use server` 指令：

`/app/lib/actions.ts`
```ts
'use server';
```

透過添加 `'use server'`，您將檔案中所有導出的函數標記為 Server Actions。然後，這些伺服器函數可以被匯入並在客戶端和伺服器元件中使用。

您也可以直接在伺服器元件內部編寫 Server Actions，只需在 action 內部添加 `"use server"`。但對於本課程，我們將它們全部組織在一個單獨的檔案中。

在您的 `actions.ts` 檔案中，建立一個新的 `async` 函數，它接受 `formData`：

`/app/lib/actions.ts`
```ts
'use server';
 
export async function createInvoice(formData: FormData) {}
```

然後，在您的 `<Form>` 元件中，從 `actions.ts` 檔案匯入 `createInvoice`。向 `<form>` 元素添加一個 `action` 屬性，並調用 `createInvoice` action。

`/app/ui/invoices/create-form.tsx`
```tsx
import { CustomerField } from '@/app/lib/definitions';
import Link from 'next/link';
import {
  CheckIcon,
  ClockIcon,
  CurrencyDollarIcon,
  UserCircleIcon,
} from '@heroicons/react/24/outline';
import { Button } from '@/app/ui/button';
import { createInvoice } from '@/app/lib/actions';
 
export default function Form({
  customers,
}: {
  customers: CustomerField[];
}) {
  return (
    <form action={createInvoice}>
      {/* ... */}
    </form>
  )
}
```

> **值得注意的是**：在 HTML 中，您會將一個 URL 傳遞給 `action` 屬性。這個 URL 將是您的表單資料應該提交的目的地（通常是一個 API 端點）。然而，在 React 中，`action` 屬性被視為一個特殊的 prop——意味著 React 在其基礎上進行構建，以允許調用 actions。在幕後，Server Actions 會創建一個 POST API 端點。這就是為什麼在使用 Server Actions 時，您不需要手動創建 API 端點。

### 3. 從 formData 中提取資料

回到您的 `actions.ts` 檔案，您需要提取 `formData` 的值，您可以使用幾種方法。對於本例，讓我們使用 `.get(name)` 方法。

`/app/lib/actions.ts`
```ts
'use server';
 
export async function createInvoice(formData: FormData) {
  const rawFormData = {
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  };
  // 測試一下：
  console.log(rawFormData);
}
```
> **提示**：如果您正在處理有很多欄位的表單，您可能想考慮使用 `entries()` 方法與 JavaScript 的 `Object.fromEntries()`。

為了檢查一切是否連接正確，試用一下表單。提交後，您應該會在您的終端機（而不是瀏覽器）中看到您剛剛輸入到表單中的資料被記錄下來。

### 4. 驗證並準備資料

在將表單資料發送到您的資料庫之前，您需要確保它的格式和型別都正確。如果您還記得課程前面的內容，您的 `invoices` 表期望的資料格式如下：

`/app/lib/definitions.ts`
```ts
export type Invoice = {
  id: string; // 將在資料庫中創建
  customer_id: string;
  amount: number; // 以分為單位儲存
  status: 'pending' | 'paid';
  date: string;
};
```

到目前為止，您只有來自表單的 `customer_id`、`amount` 和 `status`。

#### 型別驗證與強制轉換

驗證表單資料與資料庫中預期的型別是否一致非常重要。例如，如果您在 action 中添加一個 `console.log`：
```ts
console.log(typeof rawFormData.amount);
```
您會注意到 `amount` 的型別是 `string` 而不是 `number`。這是因為 `type="number"` 的 `input` 元素實際上返回一個字串，而不是數字！

為了處理型別驗證，您有幾個選擇。雖然您可以手動驗證型別，但使用型別驗證函式庫可以節省您的時間和精力。對於您的範例，我們將使用 **Zod**，一個 TypeScript-first 的驗證函式庫，它可以簡化這項任務。

在您的 `actions.ts` 檔案中，匯入 Zod 並定義一個與您的表單物件形狀相符的 schema。此 schema 將在將 `formData` 儲存到資料庫之前對其進行驗證。

`/app/lib/actions.ts`
```ts
'use server';
 
import { z } from 'zod';
 
const FormSchema = z.object({
  id: z.string(),
  customerId: z.string(),
  amount: z.coerce.number(),
  status: z.enum(['pending', 'paid']),
  date: z.string(),
});
 
const CreateInvoice = FormSchema.omit({ id: true, date: true });
 
export async function createInvoice(formData: FormData) {
  // ...
}
```
`amount` 欄位被特別設定為從字串**強制轉換 (coerce)** 為數字，同時也驗證其型別。

然後，您可以將您的 `rawFormData` 傳遞給 `CreateInvoice` 來驗證型別：
`/app/lib/actions.ts`
```ts
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
}
```

#### 以分為單位儲存值

通常，將貨幣值以**分**為單位儲存在您的資料庫中是一個好習慣，以消除 JavaScript 的浮點數錯誤並確保更高的精度。

讓我們將 `amount` 轉換為分：
`/app/lib/actions.ts`
```ts
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    //...
  });
  const amountInCents = amount * 100;
}
```

#### 創建新日期
最後，讓我們為發票的創建日期創建一個 "YYYY-MM-DD" 格式的新日期：
`/app/lib/actions.ts`
```ts
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    // ...
  });
  const amountInCents = amount * 100;
  const date = new Date().toISOString().split('T')[0];
}
```

### 5. 將資料插入到您的資料庫中

現在您已經擁有了資料庫所需的所有值，您可以創建一個 SQL 查詢來將新發票插入到您的資料庫中，並傳入變數：

`/app/lib/actions.ts`
```ts
import { z } from 'zod';
import postgres from 'postgres';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
 
// ...
 
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
  const amountInCents = amount * 100;
  const date = new Date().toISOString().split('T')[0];
 
  await sql`
    INSERT INTO invoices (customer_id, amount, status, date)
    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
  `;
}
```
目前，我們沒有處理任何錯誤。我們將在下一章中討論這個問題。

### 6. 重新驗證並重新導向

Next.js 有一個客戶端路由快取，它在使用者瀏覽器中儲存路由區段一段時間。與預取 (prefetching) 一起，此快取確保使用者可以在路由之間快速導航，同時減少向伺服器發出的請求數量。

由於您正在更新發票路由中顯示的資料，您需要清除此快取並觸發對伺服器的新請求。您可以使用 Next.js 的 `revalidatePath` 函數來實現此功能：

`/app/lib/actions.ts`
```ts
'use server';
 
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import postgres from 'postgres';
 
// ...
 
export async function createInvoice(formData: FormData) {
  // ...
 
  await sql`
    INSERT INTO invoices (customer_id, amount, status, date)
    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
  `;
 
  revalidatePath('/dashboard/invoices');
}
```

一旦資料庫更新，`/dashboard/invoices` 路徑將被重新驗證，並且將從伺服器獲取新資料。

此時，您還希望將使用者重新導向回 `/dashboard/invoices` 頁面。您可以使用 Next.js 的 `redirect` 函數來實現此功能：

`/app/lib/actions.ts`
```ts
'use server';
 
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import postgres from 'postgres';
 
// ...
 
export async function createInvoice(formData: FormData) {
  // ...
 
  revalidatePath('/dashboard/invoices');
  redirect('/dashboard/invoices');
}
```

恭喜！您剛剛實現了您的第一個 Server Action。通過添加新發票來測試它，如果一切正常：
-   提交後您應該被重新導向到 `/dashboard/invoices` 路由。
-   您應該在表格頂部看到新發票。

## 更新發票

更新發票的表單與創建發票的表單相似，只是您需要傳遞發票 ID 來更新資料庫中的記錄。讓我們看看如何獲取並傳遞發票 ID。

以下是您更新發票將採取的步驟：
1.  使用發票 ID 建立一個新的動態路由區段。
2.  從頁面參數中讀取發票 ID。
3.  從您的資料庫中獲取特定的發票。
4.  使用發票資料預先填充表單。
5.  在您的資料庫中更新發票資料。

### 1. 使用發票 ID 建立動態路由區段

Next.js 允許您在不知道確切區段名稱並希望根據資料創建路由時創建**動態路由區段 (Dynamic Route Segments)**。這可能是部落格文章標題、產品頁面等。您可以通過將資料夾名稱包裹在方括號中來創建動態路由區段。例如，`[id]`、`[post]` 或 `[slug]`。

在您的 `/invoices` 資料夾中，創建一個名為 `[id]` 的新動態路由，然後在其中創建一個名為 `edit` 的新路由，並附帶一個 `page.tsx` 檔案。您的檔案結構應如下所示：

![編輯發票路由](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Flearn%2Fdark%2Fedit-invoice-route.png&w=3840&q=75)

在您的 `<Table>` 元件中，注意有一個 `<UpdateInvoice />` 按鈕，它從表格記錄中接收發票的 `id`。

`/app/ui/invoices/table.tsx`
```tsx
export default async function InvoicesTable({
  query,
  currentPage,
}: {
  query: string;
  currentPage: number;
}) {
  return (
    // ...
    <td className="flex justify-end gap-2 whitespace-nowrap px-6 py-4 text-sm">
      <UpdateInvoice id={invoice.id} />
      <DeleteInvoice id={invoice.id} />
    </td>
    // ...
  );
}
```

導航到您的 `<UpdateInvoice />` 元件，並更新 `Link` 的 `href` 以接受 `id` prop。您可以使用模板字面量來連結到動態路由區段：

`/app/ui/invoices/buttons.tsx`
```tsx
import { PencilIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';
 
// ...
 
export function UpdateInvoice({ id }: { id: string }) {
  return (
    <Link
      href={`/dashboard/invoices/${id}/edit`}
      className="rounded-md border p-2 hover:bg-gray-100"
    >
      <PencilIcon className="w-5" />
    </Link>
  );
}
```

### 2. 從頁面參數中讀取發票 ID

回到您的 `<Page>` 元件，貼上以下程式碼：

`/app/dashboard/invoices/[id]/edit/page.tsx`
```tsx
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Edit Invoice',
            href: `/dashboard/invoices/${id}/edit`,
            active: true,
          },
        ]}
      />
      <Form invoice={invoice} customers={customers} />
    </main>
  );
}
```

注意它與您的 `/create` 發票頁面相似，只是它匯入了一個不同的表單（來自 `edit-form.tsx` 檔案）。此表單應預先填充客戶名稱、發票金額和狀態的 `defaultValue`。要預先填充表單欄位，您需要使用 `id` 獲取特定的發票。

除了 `searchParams`，頁面元件還接受一個名為 `params` 的 prop，您可以使用它來存取 `id`。更新您的 `<Page>` 元件以接收該 prop：

`/app/dashboard/invoices/[id]/edit/page.tsx`
```tsx
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page({ params }: { params: { id: string } }) {
  const id = params.id;
  // ...
}
```

### 3. 獲取特定的發票

然後：

-   匯入一個名為 `fetchInvoiceById` 的新函數並傳遞 `id` 作為參數。
-   匯入 `fetchCustomers` 以獲取客戶名稱用於下拉列表。
-   您可以使用 `Promise.all` 並行獲取發票和客戶：

`/dashboard/invoices/[id]/edit/page.tsx`
```tsx
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';
 
export default async function Page({ params }: { params: { id: string } }) {
  const id = params.id;
  const [invoice, customers] = await Promise.all([
    fetchInvoiceById(id),
    fetchCustomers(),
  ]);
  // ...
}
```

您將在終端機中看到一個關於 `invoice` prop 的臨時 TypeScript 錯誤，因為 `invoice` 可能會是 `undefined`。現在不用擔心，您將在下一章添加錯誤處理時解決它。

太棒了！現在，測試一切是否連接正確。訪問 `http://localhost:3000/dashboard/invoices` 並點擊鉛筆圖示來編輯發票。導航後，您應該會看到一個預先填充了發票詳細資訊的表單。URL 也應該更新為帶有 id 的，如下所示：`http://localhost:3000/dashboard/invoice/uuid/edit`。

#### UUIDs vs. 自動遞增鍵

我們使用 UUIDs 而不是遞增鍵（例如，1, 2, 3 等）。這使得 URL 更長；然而，UUIDs 消除了 ID 衝突的風險，是全域唯一的，並降低了枚舉攻擊的風險——使其成為大型資料庫的理想選擇。但是，如果您更喜歡更簡潔的 URL，您可能更喜歡使用自動遞增鍵。

### 4. 將 id 傳遞給 Server Action

最後，您希望將 `id` 傳遞給 Server Action，以便您可以在資料庫中更新正確的記錄。您不能像這樣將 id 作為參數傳遞：
`/app/ui/invoices/edit-form.tsx`
```tsx
// 這樣傳遞 id 作為參數是行不通的
<form action={updateInvoice(id)}>
```

相反，您可以使用 JS 的 `bind` 將 `id` 傳遞給 Server Action。這將確保傳遞給 Server Action 的任何值都被編碼。

`/app/ui/invoices/edit-form.tsx`
```tsx
// ...
import { updateInvoice } from '@/app/lib/actions';
 
export default function EditInvoiceForm({
  invoice,
  customers,
}: {
  invoice: InvoiceForm;
  customers: CustomerField[];
}) {
  const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);
 
  return <form action={updateInvoiceWithId}>{/* ... */}</form>;
}
```
> **注意**：在您的表單中使用隱藏的輸入欄位也有效（例如 `<input type="hidden" name="id" value={invoice.id} />`）。但是，這些值將以純文本形式出現在 HTML 原始碼中，這對於敏感資料並不理想。

然後，在您的 `actions.ts` 檔案中，創建一個名為 `updateInvoice` 的新 action：
`/app/lib/actions.ts`
```ts
// 使用 Zod 更新預期的型別
const UpdateInvoice = FormSchema.omit({ id: true, date: true });
 
// ...
 
export async function updateInvoice(id: string, formData: FormData) {
  const { customerId, amount, status } = UpdateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
 
  const amountInCents = amount * 100;
 
  await sql`
    UPDATE invoices
    SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}
    WHERE id = ${id}
  `;
 
  revalidatePath('/dashboard/invoices');
  redirect('/dashboard/invoices');
}
```
與 `createInvoice` action 類似，在這裡您：
-   從 `formData` 中提取資料。
-   使用 Zod 驗證型別。
-   將金額轉換為分。
-   將變數傳遞給您的 SQL 查詢。
-   調用 `revalidatePath` 以清除客戶端快取並發出新的伺服器請求。
-   調用 `redirect` 將使用者重新導向到發票頁面。

通過編輯一張發票來測試它。提交表單後，您應該被重新導向到發票頁面，並且發票應該已更新。

## 刪除發票

要使用 Server Action 刪除發票，請將刪除按鈕包裹在 `<form>` 元素中，並使用 `bind` 將 `id` 傳遞給 Server Action：

`/app/ui/invoices/buttons.tsx`
```tsx
import { deleteInvoice } from '@/app/lib/actions';
 
// ...
 
export function DeleteInvoice({ id }: { id: string }) {
  const deleteInvoiceWithId = deleteInvoice.bind(null, id);
 
  return (
    <form action={deleteInvoiceWithId}>
      <button type="submit" className="rounded-md border p-2 hover:bg-gray-100">
        <span className="sr-only">Delete</span>
        <TrashIcon className="w-4" />
      </button>
    </form>
  );
}
```

在您的 `actions.ts` 檔案中，創建一個名為 `deleteInvoice` 的新 action：
`/app/lib/actions.ts`
```tsx
export async function deleteInvoice(id: string) {
  await sql`DELETE FROM invoices WHERE id = ${id}`;
  revalidatePath('/dashboard/invoices');
}
```
由於此 action 是在 `/dashboard/invoices` 路徑中調用的，您不需要調用 `redirect`。調用 `revalidatePath` 將觸發新的伺服器請求並重新渲染表格。

## 延伸閱讀

在本章中，您學習了如何使用 Server Actions 來修改資料。您還學習了如何使用 `revalidatePath` API 來重新驗證 Next.js 快取，以及使用 `redirect` 將使用者重新導向到新頁面。

您還可以閱讀更多關於 [Server Actions 的安全性](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#security)以進行額外學習。
```